"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[362],{3905:function(e,t,a){a.d(t,{Zo:function(){return k},kt:function(){return g}});var l=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,l)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,l,n=function(e,t){if(null==e)return{};var a,l,n={},r=Object.keys(e);for(l=0;l<r.length;l++)a=r[l],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(l=0;l<r.length;l++)a=r[l],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var o=l.createContext({}),m=function(e){var t=l.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},k=function(e){var t=m(e.components);return l.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return l.createElement(l.Fragment,{},t)}},p=l.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,o=e.parentName,k=s(e,["components","mdxType","originalType","parentName"]),p=m(a),g=n,c=p["".concat(o,".").concat(g)]||p[g]||d[g]||r;return a?l.createElement(c,i(i({ref:t},k),{},{components:a})):l.createElement(c,i({ref:t},k))}));function g(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,i=new Array(r);i[0]=p;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var m=2;m<r;m++)i[m]=a[m];return l.createElement.apply(null,i)}return l.createElement.apply(null,a)}p.displayName="MDXCreateElement"},4869:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return s},contentTitle:function(){return o},metadata:function(){return m},toc:function(){return k},default:function(){return p}});var l=a(7462),n=a(3366),r=(a(7294),a(3905)),i=["components"],s={sidebar_position:4},o="Optimaliz\xe1l\xe1si elj\xe1r\xe1sok",m={unversionedId:"megoldas/optimalizalasi-trukkok",id:"megoldas/optimalizalasi-trukkok",title:"Optimaliz\xe1l\xe1si elj\xe1r\xe1sok",description:"Az al\xe1bbiakban a feladat megold\xe1s\xe1val kapcsolatban szeml\xe9ltetek f\u0151bb optimaliz\xe1l\xe1si opci\xf3kat, melyek specifikusan a feladat megold\xe1s\xe1nak szempontj\xe1b\xf3l alkalmazhat\xf3ak. A val\xf3s\xe1gban alkalmaz\xe1s specifikusan tem\xe9rdek m\xe1s dologra kell figyelni \xe9s sok minden m\xe1s el\u0151j\xf6het. P\xe9ld\xe1ul az\xe9rt nem esik sz\xf3 itt a param\xe9ter\xe1tad\xe1sr\xf3l, mert ahogy az eredeti program csak trivi\xe1lisan m\xe1solhat\xf3 egyszer\u0171 t\xedpusokkal dolgozik, \xfagy a megold\xe1s is erre t\xf6rekszik.",source:"@site/docs/megoldas/optimalizalasi-trukkok.md",sourceDirName:"megoldas",slug:"/megoldas/optimalizalasi-trukkok",permalink:"/megoldas/optimalizalasi-trukkok",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Felhaszn\xe1lt technol\xf3gi\xe1k",permalink:"/megoldas/a-kornyezet-megvalasztasa"},next:{title:"Program workflow defini\xe1l\xe1sa",permalink:"/megoldas/user-view"}},k=[{value:"A modern \xe9s a r\xe9gi szeml\xe9let k\xf6zti k\xfcl\xf6nbs\xe9g",id:"a-modern-\xe9s-a-r\xe9gi-szeml\xe9let-k\xf6zti-k\xfcl\xf6nbs\xe9g",children:[{value:"V\xe9letlen-gener\xe1l\xe1s",id:"v\xe9letlen-gener\xe1l\xe1s",children:[],level:3},{value:"Goto",id:"goto",children:[],level:3},{value:"Constexpr vs Macro",id:"constexpr-vs-macro",children:[],level:3},{value:"Matematikai m\u0171veletek",id:"matematikai-m\u0171veletek",children:[],level:3}],level:2},{value:"Ford\xedt\xf3 b\u0151v\xedtm\xe9nyek \xe9s egy\xe9b m\xf3dos\xedt\xf3k",id:"ford\xedt\xf3-b\u0151v\xedtm\xe9nyek-\xe9s-egy\xe9b-m\xf3dos\xedt\xf3k",children:[{value:"inline / always_inline",id:"inline--always_inline",children:[],level:3},{value:"restrict",id:"restrict",children:[],level:3},{value:"cleanup",id:"cleanup",children:[],level:3}],level:2},{value:"SIMD",id:"simd",children:[],level:2},{value:"Egyedi allok\xe1torok",id:"egyedi-allok\xe1torok",children:[{value:"\xc1ltal\xe1nos allok\xe1torok",id:"\xe1ltal\xe1nos-allok\xe1torok",children:[{value:"VLA/alloca/malloca",id:"vlaallocamalloca",children:[],level:4},{value:"\xc1ltal\xe1nos allok\xe1torok elt\xe9r\u0151 implement\xe1ci\xf3val",id:"\xe1ltal\xe1nos-allok\xe1torok-elt\xe9r\u0151-implement\xe1ci\xf3val",children:[],level:4}],level:3},{value:"Pool allok\xe1torok",id:"pool-allok\xe1torok",children:[],level:3}],level:2},{value:"GPU offloading",id:"gpu-offloading",children:[],level:2}],d={toc:k};function p(e){var t=e.components,s=(0,n.Z)(e,i);return(0,r.kt)("wrapper",(0,l.Z)({},d,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"optimaliz\xe1l\xe1si-elj\xe1r\xe1sok"},"Optimaliz\xe1l\xe1si elj\xe1r\xe1sok"),(0,r.kt)("p",null,"Az al\xe1bbiakban a feladat megold\xe1s\xe1val kapcsolatban szeml\xe9ltetek f\u0151bb optimaliz\xe1l\xe1si opci\xf3kat, melyek specifikusan a feladat megold\xe1s\xe1nak szempontj\xe1b\xf3l alkalmazhat\xf3ak. A val\xf3s\xe1gban alkalmaz\xe1s specifikusan tem\xe9rdek m\xe1s dologra kell figyelni \xe9s sok minden m\xe1s el\u0151j\xf6het. P\xe9ld\xe1ul az\xe9rt nem esik sz\xf3 itt a param\xe9ter\xe1tad\xe1sr\xf3l, mert ahogy az eredeti program csak trivi\xe1lisan m\xe1solhat\xf3 egyszer\u0171 t\xedpusokkal dolgozik, \xfagy a megold\xe1s is erre t\xf6rekszik."),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Fontos lesz\xf6gezni m\xe1r az elej\xe9n, hogy a legjobb \xe9s legfontosabb optimaliz\xe1l\xe1si m\xf3dszer mindig a feladat szempontj\xe1b\xf3l a leghat\xe9konyabb algoritmus megtal\xe1l\xe1sa."))),(0,r.kt)("h2",{id:"a-modern-\xe9s-a-r\xe9gi-szeml\xe9let-k\xf6zti-k\xfcl\xf6nbs\xe9g"},"A modern \xe9s a r\xe9gi szeml\xe9let k\xf6zti k\xfcl\xf6nbs\xe9g"),(0,r.kt)("p",null,'Jellemz\u0151en "greenfield" projektekn\xe9l halljuk azt a tan\xe1csot, hogy ha m\xf3dunkban \xe1ll, mindig haszn\xe1ljunk modern implement\xe1ci\xf3kat.\nGondoljunk p\xe9ld\xe1ul egy hagyom\xe1nyos dinamikus t\xf6mb \xe9s egy ',(0,r.kt)("inlineCode",{parentName:"p"},"std::vector")," k\xf6zti k\xfcl\xf6nbs\xe9gekre. Az ut\xf3bbi haszn\xe1lata sz\xe1mos el\u0151re defini\xe1lt funkcional\xedt\xe1ssal seg\xedti a programoz\xe1st, \xe9s a mem\xf3ria felszabad\xedt\xe1s\xe1val sem kell foglalkoznunk (l\xe1sd ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization"},"RAII"),"). De m\xe9g ha a dinamikus mem\xf3riakezel\xe9st nem is vessz\xfck figyelembe, akkor is aj\xe1nlatosabb egy hagyom\xe1nyos C t\xf6mb helyett egy ",(0,r.kt)("inlineCode",{parentName:"p"},"std::array")," haszn\xe1lata, m\xe1rcsak param\xe9ter\xe1tad\xe1s szempontj\xe1b\xf3l is."),(0,r.kt)("p",null,"Alapvet\u0151en a modern eszk\xf6z\xf6k haszn\xe1lata prefer\xe1lt minden esetben, kiv\xe9telt k\xe9peznek ez al\xf3l a teljes\xedtm\xe9nyorient\xe1lt rendszerek, illetve azok, amelyeknek implement\xe1ci\xf3ja m\xe1r megt\xf6rt\xe9nt, \xe9s tov\xe1bbi optimaliz\xe1l\xe1si lehet\u0151s\xe9geket keres\xfcnk."),(0,r.kt)("p",null,'A modern megold\xe1sok ny\xfajtotta k\xe9nyelem \xe9s a hibalehet\u0151s\xe9gek minimaliz\xe1l\xe1sa az esetek nagyr\xe9sz\xe9ben a teljes\xedtm\xe9ny rov\xe1s\xe1ra megy.\nNem l\xe9tezik "k\xf6lts\xe9gmentes absztrakci\xf3". Min\xe9l k\xf6zelebb dolgozik a fejleszt\u0151 a mem\xf3ri\xe1val, ann\xe1l t\xf6bb lehet\u0151s\xe9ge van optim\xe1lis k\xf3d \xedr\xe1s\xe1ra, amit a k\xf3d min\u0151s\xe9g\xe9nek \xe9s olvashat\xf3s\xe1g\xe1nak k\xe1r\xe1ra \xe9r el. Projekt \xe9s fejleszt\u0151 f\xfcgg\u0151 az optim\xe1lis egyens\xfaly megtal\xe1l\xe1sa.'),(0,r.kt)("br",null),"Egy p\xe9lda a fentebb v\xe1zolt hasonlatra:",(0,r.kt)("br",null),(0,r.kt)("br",null),"(Haszn\xe1lt compiler: Clang 13.0 -O0 kapcsol\xf3val)",(0,r.kt)("br",null),(0,r.kt)("br",null),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <vector>\n\nint main() {\n  std::vector<int> vec(5);\n  return 0;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-nasm"},'main:                                   # @main\n        push    rbp\n        mov     rbp, rsp\n        sub     rsp, 64\n        lea     rdi, [rbp - 32]\n        mov     qword ptr [rbp - 56], rdi       # 8-byte Spill\n        call    std::allocator<int>::allocator() [base object constructor]\n        mov     rdx, qword ptr [rbp - 56]       # 8-byte Reload\n        lea     rdi, [rbp - 24]\n        mov     esi, 5\n        call    std::vector<int, std::allocator<int> >::vector(unsigned long, std::allocator<int> const&) [base object constructor]\n        jmp     .LBB0_1\n.LBB0_1:\n        lea     rdi, [rbp - 32]\n        call    std::allocator<int>::~allocator() [base object destructor]\n        lea     rdi, [rbp - 24]\n        call    std::vector<int, std::allocator<int> >::~vector() [base object destructor]\n        xor     eax, eax\n        add     rsp, 64\n        pop     rbp\n        ret\n        mov     rcx, rax\n        mov     eax, edx\n        mov     qword ptr [rbp - 40], rcx\n        mov     dword ptr [rbp - 44], eax\n        lea     rdi, [rbp - 32]\n        call    std::allocator<int>::~allocator() [base object destructor]\n        mov     rdi, qword ptr [rbp - 40]\n        call    _Unwind_Resume@PLT\n__clang_call_terminate:                 # @__clang_call_terminate\n        push    rax\n        call    __cxa_begin_catch\n        call    std::terminate()\n.L.str:\n        .asciz  "cannot create std::vector larger than max_size()"\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <stdlib.h>\n\nint main() {\nint* vec = static_cast<int*>(calloc(5, sizeof(int)));\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-nasm"},"main:                                   # @main\n        push    rbp\n        mov     rbp, rsp\n        sub     rsp, 16\n        mov     edi, 5\n        mov     esi, 4\n        call    calloc\n        mov     qword ptr [rbp - 8], rax\n        xor     eax, eax\n        add     rsp, 16\n        pop     rbp\n        ret\n")),(0,r.kt)("p",null,"Mint az l\xe1that\xf3, a k\xe9t p\xe9lda teljesen m\xe1s assembly k\xf3dra fordul.",(0,r.kt)("br",null),"\nAz ",(0,r.kt)("inlineCode",{parentName:"p"},"std::vector")," \xe1ltali bels\u0151 \xe1llapotkezel\xe9s, illetve a konstructor \xe9s destruktor h\xedv\xe1s dr\xe1maian megn\xf6velte a ford\xedtott k\xf3d m\xe9ret\xe9t."),(0,r.kt)("p",null,"Ez csak egy egyszer\u0171 p\xe9lda arra, hogy att\xf3l, hogy modernebb nyelvi eszk\xf6z\xf6ket tesz\xfcnk egy programba, az m\xe9g nem felt\xe9tlen lesz minden esetben gyorsabb (s\u0151t...)."),(0,r.kt)("p",null,"A legjobb \xfat valahol a kett\u0151 k\xf6z\xf6tt van, meg kell tal\xe1lni azt a utat, ahol a k\xe9nyelmi funkci\xf3k, teljes\xedtm\xe9ny, helyes hibakezel\xe9s \xe9s clean code (ki akar t\xf6bb t\xedz soros ",(0,r.kt)("inlineCode",{parentName:"p"},"free_everything(...)")," jelleg\u0171 funkci\xf3kat \xedrni?) tal\xe1lkozik."),(0,r.kt)("h3",{id:"v\xe9letlen-gener\xe1l\xe1s"},"V\xe9letlen-gener\xe1l\xe1s"),(0,r.kt)("p",null,"V\xe9letlen gener\xe1l\xe1sra a de facto m\xf3dszer a ",(0,r.kt)("inlineCode",{parentName:"p"},"rand()")," \xe9s az ",(0,r.kt)("inlineCode",{parentName:"p"},"srand()"),". M\xedg az ut\xf3bbival a ",(0,r.kt)("inlineCode",{parentName:"p"},"rand()")," \xe1ltal haszn\xe1lt seed-et inicializ\xe1ljuk, addig az el\u0151bbivel t\xf6rt\xe9nik a [0, RAND_MAX) intervallumban t\xf6rt\xe9n\u0151 v\xe9letlensz\xe1m-gener\xe1l\xe1s. A probl\xe9ma ezzel a megold\xe1ssal az, hogy glob\xe1lis \xe1llapotot haszn\xe1l, ez\xe1ltal konkurrens v\xe9letlensz\xe1m-gener\xe1l\xe1sra nem alkalmas. Modern alternat\xedv\xe1i a Mersenne Twister algoritmuson alapul\xf3 standard k\xf6nyvt\xe1rban tal\xe1lhat\xf3 implement\xe1ci\xf3i. Az implement\xe1ci\xf3 \xe9rdekess\xe9ge, hogy b\xe1r megadhat\xf3 param\xe9terk\xe9nt el\u0151re defini\xe1lt seed v\xe1ltoz\xf3, nem k\xf6telez\u0151 ezt megadni. (De ennek hi\xe1nya miatt nem fognak minden programfut\xe1skor ugyanazok a v\xe9letlenek gener\xe1l\xf3dni, mint a ",(0,r.kt)("inlineCode",{parentName:"p"},"rand()")," eset\xe9n.) \xcdgy a v\xe9letlenkezel\xe9s is biztos\xedtott, de a seed haszn\xe1lat\xe1val a tesztelhet\u0151s\xe9g is megmarad.\nA v\xe9letlen gener\xe1l\xe1sra haszn\xe1lt template oszt\xe1lyok az ",(0,r.kt)("inlineCode",{parentName:"p"},"std::uniform_real_distribution<T>")," \xe9s az ",(0,r.kt)("inlineCode",{parentName:"p"},"std::uniform_int_distribution<T>"),".",(0,r.kt)("br",null),"\nHaszn\xe1latra egy p\xe9ldak\xf3d:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"inline double random_between(const double low, const double high)\n{\n    const std::uniform_real_distribution<double> dist(low, high);\n    std::mt19937 rng(std::random_device {}());\n    return dist(rng);\n}\n")),(0,r.kt)("h3",{id:"goto"},"Goto"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"goto")," alap\xfa folyamatvez\xe9rl\xe9s er\u0151sen antipatternnek sz\xe1m\xedt az esetek 99.999%-\xe1ban. Egyetlen mai szemmel re\xe1lis felhaszn\xe1l\xe1si ter\xfclete a t\xf6bbsz\xf6r\xf6sen be\xe1gyazott ",(0,r.kt)("inlineCode",{parentName:"p"},"for")," ciklusb\xf3l t\xf6rt\xe9n\u0151 kil\xe9p\xe9s bizonyos adott teljes\xfcl\xe9se eset\xe9n. Fejleszt\u0151i szemmel n\xe9zve spagetti k\xf3dot eredm\xe9nyez, teljes\xedtm\xe9ny fel\u0151l megk\xf6zel\xedtve pedig kikapcsol minden CPU-ban \xe9s ford\xedt\xf3ban tal\xe1lhat\xf3 branchel\xe9si optimaliz\xe1ci\xf3t.\nMivel t\xf6bb matematikai met\xf3dus is ilyen m\xf3don van implement\xe1lva, ezeknek az \xe1t\xedr\xe1sa egy optimaliz\xe1l\xe1si lehet\u0151s\xe9g."),(0,r.kt)("h3",{id:"constexpr-vs-macro"},"Constexpr vs Macro"),(0,r.kt)("p",null,"A constexpr kulcssz\xf3 \xe9s az azt megel\u0151z\u0151 ",(0,r.kt)("a",{parentName:"p",href:"https://hu.wikipedia.org/wiki/Template_metaprogramoz%C3%A1s"},"meta-programoz\xe1s")," fogalma szorosan \xf6sszekapcsol\xf3dik. Mindkett\u0151 arra hivatott, hogy a makr\xf3k haszn\xe1lat\xe1t visszaszor\xedts\xe1k. A constexpr kulcssz\xf3val ell\xe1tott v\xe1ltoz\xf3knak van t\xe9nyleges mem\xf3riater\xfclete (l\xe1sd: ",(0,r.kt)("inlineCode",{parentName:"p"},"int max = std::max(1, RANDOM_INTEGER_MACRO)")," => undefined behaviour), tov\xe1bb\xe1 rendelkeznek l\xe1t\xf3k\xf6rrel, \xedgy nem kell att\xf3l tartanunk, hogy n\xe9v\xfctk\xf6z\xe9s \xe1llna fent, vagy hogy a glob\xe1lis namespace-t teleszemeteln\xe9nk.A constexpr, meta-programoz\xe1s (\xe9s C++20 \xf3ta a ",(0,r.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/consteval"},"consteval"),") rendelkezik tov\xe1bb\xe1 azzal a tulajdons\xe1ggal, hogy a ford\xedt\xe1si id\u0151ben ismert v\xe1ltoz\xf3kkal ford\xedt\xe1si id\u0151ben m\u0171veleteket v\xe9gezz\xfcnk. \xc9rtelemszer\u0171en ez azzal j\xe1r, hogy a ford\xedt\xe1si id\u0151 megn\xf6vekszik."),(0,r.kt)("p",null,"Vegy\xfck p\xe9ld\xe1ul az al\xe1bbi k\xf3dot:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"constexpr double custom_pow(double x, int y)\n{\n    return y == 0 ? 1.0 : x * custom_pow(x, y - 1);\n}\n\nconstexpr double pow_with_constexpr = custom_pow(100000, 35);\n\ndouble pow_without_constexpr = custom_pow(100000, 35);\n\n")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Constexpr example",src:a(2133).Z})),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Ha tehetj\xfck, a ford\xedt\xe1si id\u0151ben ismert v\xe1ltoz\xf3kat mindig l\xe1ssuk el constexpr m\xf3dos\xedt\xf3val!"))),(0,r.kt)("h3",{id:"matematikai-m\u0171veletek"},"Matematikai m\u0171veletek"),(0,r.kt)("p",null,"A C \xe9s C++ matematikai k\xf6nyvt\xe1rak k\xf6zti k\xfcl\xf6nbs\xe9gek k\xf6zt megeml\xedthet\u0151, hogy ut\xf3bbi m\xe1r standard implement\xe1ci\xf3t\xf3l f\xfcgg\u0151en tartalmazza a constexpr kulcssz\xf3val j\xe1r\xf3 el\u0151ny\xf6ket, tov\xe1bb\xe1 ett\u0151l eltekintve a C++ standard sz\xe1mos olyan fejl\xe9cf\xe1jlt tartalmaz, mint p\xe9ld\xe1ul a ",(0,r.kt)("inlineCode",{parentName:"p"},"<random>"),", amik seg\xedts\xe9g\xe9vel a jelenlegi implement\xe1ci\xf3kat lecser\xe9lve az eddigi k\xf3db\xe1zis m\xe9rete jelent\u0151sen cs\xf6kken."),(0,r.kt)("h2",{id:"ford\xedt\xf3-b\u0151v\xedtm\xe9nyek-\xe9s-egy\xe9b-m\xf3dos\xedt\xf3k"},"Ford\xedt\xf3 b\u0151v\xedtm\xe9nyek \xe9s egy\xe9b m\xf3dos\xedt\xf3k"),(0,r.kt)("p",null,"Az al\xe1bbiakban n\xe9h\xe1ny teljes\xedtm\xe9ny szempontj\xe1b\xf3l hasznos m\xf3dos\xedt\xf3 kulcssz\xf3t \xe9s nem standard ford\xedt\xf3 b\u0151v\xedtm\xe9nyt mutatok be."),(0,r.kt)("h3",{id:"inline--always_inline"},"inline / always_inline"),(0,r.kt)("p",null,"Az ",(0,r.kt)("inlineCode",{parentName:"p"},"inline"),' m\xf3dos\xedt\xf3sz\xf3 seg\xedts\xe9g\xe9vel el\xe9rhetj\xfck, hogy r\xf6vid met\xf3dusainkat a ford\xedt\xf3 ne k\xfcl\xf6n\xe1ll\xf3 met\xf3dusk\xe9nt kezelje, hanem megh\xedv\xe1s sor\xe1n "\xe1gyazza be" a met\xf3dust\xf6rzset a h\xedv\xe1s hely\xe9re. Jellemz\u0151en getter-setter met\xf3dusokn\xe1l haszn\xe1lj\xe1k, de b\xe1rmilyen kism\xe9ret\u0171 elj\xe1r\xe1s eset\xe9n alkalmazhat\xf3. Mivel els\u0151sorban csak egy tippnek szolg\xe1l a ford\xedt\xf3 sz\xe1m\xe1ra, amit figyelmen k\xedv\xfcl hagyhat, az ',(0,r.kt)("inlineCode",{parentName:"p"},"always_inline"),' ford\xedt\xf3 b\u0151v\xedtm\xe9ny seg\xedts\xe9g\xe9vel "er\u0151szakolhatjuk ki" az elv\xe1rt m\u0171k\xf6d\xe9st. Gyakorlatilag ami t\xf6rt\xe9nik az az, hogy meg tudunk sp\xf3rolni assembly szinten j\xf3p\xe1r ',(0,r.kt)("inlineCode",{parentName:"p"},"jmp")," m\u0171veletet."),(0,r.kt)("h3",{id:"restrict"},"restrict"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"restrict")," kulcssz\xf3 a Fortran programoz\xe1si nyelvb\u0151l ismeretes. A C11 szabv\xe1ny r\xe9sze, azonban a C++ szabv\xe1nyba nem ker\xfclt bele. L\xe9nyege, hogy mutat\xf3 vagy referencia \xe1tad\xe1sn\xe1l a ford\xedt\xf3 sz\xe1m\xe1ra tudatjuk, hogy az adott referencia vagy mutat\xf3 az egyetlen m\xf3d arra, hogy el\xe9rj\xfck a m\xf6g\xf6ttes objektumot, ez\xe1ltal elker\xfclve az esetleges aliasing felold\xe1sb\xf3l sz\xe1rmaz\xf3 t\xf6bbletmunk\xe1t. Ha megs\xe9rtj\xfck ezt a krit\xe9riumot, az nemdefini\xe1lt viselked\xe9st eredm\xe9nyez. Kifejezetten hat\xe9kony t\xf6bb t\xf6mb\xf6n v\xe9gzett m\u0171velet eset\xe9n, ahol t\xf6bb t\xf6mb param\xe9ter eset\xe9n ezzel a kulcssz\xf3val biztos\xedtjuk a ford\xedt\xf3nak, hogy a k\xe9t t\xf6mb nem egyezik meg."),(0,r.kt)("h3",{id:"cleanup"},"cleanup"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"cleanup")," attrib\xfatum seg\xedts\xe9g\xe9vel megadhatjuk, hogy egy v\xe1ltoz\xf3 jelenlegi scope-b\xf3l t\xf6rt\xe9n\u0151 kil\xe9p\xe9sekor milyen elj\xe1r\xe1s fusson le. Nem C++ specifikus megold\xe1s. Haszn\xe1lat\xe1val k\xf3dunk min\u0151s\xe9g\xe9n seg\xedthet\xfcnk az\xe1ltal, hogy nem kell a felszabad\xedt\xe1ssal foglalkoznunk. M\u0171k\xf6dik ",(0,r.kt)("inlineCode",{parentName:"p"},"std::exception")," dob\xe1sa eset\xe9n is."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#define autofree __attribute__((cleanup(free_mem)))\n\n__attribute__((always_inline))\ninline void free_mem(void* ptr) {\n    free(*(void**)ptr);\n}\n\nint main()\n{\n    autofree int* arr = static_cast<int*>(calloc(5,sizeof(int)));\n    return 0;\n}\n")),(0,r.kt)("h2",{id:"simd"},"SIMD"),(0,r.kt)("p",null,"A ",(0,r.kt)("a",{parentName:"p",href:"https://hu.wikipedia.org/wiki/SIMD"},"SIMD")," alap\xfa feldolgoz\xe1s l\xe9nyege az, hogy az elemi m\u0171veleteket egyszerre \xe9s egyid\u0151ben v\xe9gezz\xfcnk el egy tetsz\u0151leges vektor \xf6sszes elem\xe9re. Leg\xfajabb gyakorlati megval\xf3s\xedt\xe1sai, az AVX (Advanced Vector Extensions) \xe9s AVX2 \xe1ltal ker\xfcltek bele az x86 architekt\xfar\xe1ba, amit mind az Intel, mint pedig az AMD t\xe1mogat. Programoz\xf3i szemmel n\xe9zve ez nek\xfcnk az\xe9rt j\xf3, mert \xfagy tudjuk optimaliz\xe1lni a k\xf3dot, hogy az \xe9rt\xe9kead\xe1shoz tartoz\xf3 aritmetikai m\u0171veleteket egybe\xedrjuk."),(0,r.kt)("p",null,"P\xe9ld\xe1ul itt van ez a k\xe9t met\xf3dus."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// SIMD\nvoid sum_work(const float* arr1, const float* arr2, float* arr3, const float constant, const int length)\n{\n    for(int i = 0; i < length; i++)\n    {\n        arr3[i] = constant + arr1[i] + arr2[i];\n    }\n}\n\n// NON-SIMD\nvoid bad_sum_work(const float* arr1, const float* arr2, float* arr3, const float constant, const int length)\n{\n    for (int i = 0; i < length; i++)\n    {\n        arr3[i] = constant + arr1[i];\n        arr3[i] = arr3[i] + arr2[i];\n    }\n}\n")),(0,r.kt)("p",null,"Ut\xf3bbi \xe1rtalmatlannak t\u0171nhet, hiszen az \xf6sszead\xe1s, mint m\u0171velet, k\xe9tszer szerepel, m\xe9gis teljesen elt\xe9r\u0151 teljes\xedtm\xe9nnyel futnak le."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"SIMD example",src:a(4151).Z})),(0,r.kt)("div",{className:"admonition admonition-danger alert alert--danger"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"danger")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Fontos megjegyezni, hogy ez csak akkor m\u0171k\xf6dik, ha nem \xe1ll fent az \xfagynevezett ",(0,r.kt)("strong",{parentName:"p"},"adat f\xfcgg\u0151s\xe9g")," jelens\xe9ge.\nHa a fentebb l\xe9v\u0151 ",(0,r.kt)("inlineCode",{parentName:"p"},"sum_work()")," met\xf3dusba k\xe9t \xf6sszead\xe1s k\xf6z\xe9 beiktatunk egy z\xe1r\xf3jelet, vagy egy olyan egy\xe9b m\xe1s m\u0171veletet, ami miatt a m\u0171veletek v\xe9grehajthat\xf3s\xe1g\xe1nak sorrendje k\xf6t\xf6tt lesz, ez a fajta vektoriz\xe1ci\xf3 \xe1ltali teljes\xedtm\xe9ny elv\xe9sz."))),(0,r.kt)("h2",{id:"egyedi-allok\xe1torok"},"Egyedi allok\xe1torok"),(0,r.kt)("h3",{id:"\xe1ltal\xe1nos-allok\xe1torok"},"\xc1ltal\xe1nos allok\xe1torok"),(0,r.kt)("p",null,"\xc1tal\xe1nos allok\xe1tornak nevez\xfcnk b\xe1rmi olyan mem\xf3riafoglal\xe1si elj\xe1r\xe1st, amivel a rendszer futtat\xe1sa sor\xe1n b\xe1rmikor k\xe9pesek vagyunk mem\xf3ri\xe1t foglalni \xe9s azt b\xe1rmely m\xe1s adott ponton felszabad\xedtani. Tipikus (de nem kiz\xe1r\xf3lagos) p\xe9ld\xe1k a ",(0,r.kt)("inlineCode",{parentName:"p"},"malloc()/calloc()")," \xe9s a ",(0,r.kt)("inlineCode",{parentName:"p"},"free()"),", tov\xe1bb\xe1 a ",(0,r.kt)("inlineCode",{parentName:"p"},"new/new[]")," \xe9s ",(0,r.kt)("inlineCode",{parentName:"p"},"delete/delete[]"),", de a stacken t\xf6rt\xe9n\u0151 objektum inicializ\xe1l\xe1s is. A probl\xe9ma ezekkel a megold\xe1sokkal az, hogy ah\xe1nyszor \xfaj mem\xf3ri\xe1t allok\xe1lunk, annyiszor kell az oper\xe1ci\xf3s rendszer fel\xe9 t\xf6bbleth\xedv\xe1st kezdem\xe9nyezn\xfcnk."),(0,r.kt)("h4",{id:"vlaallocamalloca"},"VLA/alloca/malloca"),(0,r.kt)("p",null,'A VLA (variable-lenght array) egy eredetileg C szabv\xe1nyelem, azonban "m\xf3dos\xedtott form\xe1ban" \xe9s ford\xedt\xf3 b\u0151v\xedtm\xe9nyk\xe9nt (de minden nagyobb ford\xedt\xf3 t\xe1mogatja) el\xe9rhet\u0151 ',(0,r.kt)("inlineCode",{parentName:"p"},"alloca/malloca")," met\xf3dusok seg\xedts\xe9g\xe9vel C++-ban is. A l\xe9nyege, hogy lehet\u0151s\xe9get biztos\xedtanak mem\xf3riafoglal\xe1sra a stack-en ford\xedt\xe1si id\u0151ben nem ismert m\xe9ret\u0171 t\xf6mb\xf6k eset\xe9ben is. Hab\xe1r nagyon cs\xe1b\xedt\xf3 lehet ez a megold\xe1s, nem szabad arr\xf3l elfeledkezni, hogy a stack alapvet\u0151en a kis mem\xf3riam\xe9ret miatt nem nagy objektumok t\xe1rol\xe1s\xe1ra lett kital\xe1lva , \xe9s ak\xe1r egy relat\xedv nagy mem\xf3riafoglal\xe1s is k\xe9pes stackoverflow hib\xe1t eredm\xe9nyezni. Emiatt haszn\xe1lat\xe1val a program sokkal s\xe9r\xfcl\xe9kenyebb lesz egy nem v\xe1rt nagyobb bemeneti \xe9rt\xe9kre ami alapj\xe1n mem\xf3ri\xe1t foglalunk. (",(0,r.kt)("a",{parentName:"p",href:"https://lkml.org/lkml/2018/3/7/621"},"Linus Tornalds VLA eml\xedt\xe9se a Linux kernelben"),")"),(0,r.kt)("h4",{id:"\xe1ltal\xe1nos-allok\xe1torok-elt\xe9r\u0151-implement\xe1ci\xf3val"},"\xc1ltal\xe1nos allok\xe1torok elt\xe9r\u0151 implement\xe1ci\xf3val"),(0,r.kt)("p",null,"Sz\xe1mos ",(0,r.kt)("inlineCode",{parentName:"p"},"malloc()/calloc()")," implement\xe1ci\xf3 sz\xfcletett az id\u0151k sor\xe1n. Akkor tudja az ember, hogy egy allok\xe1tor rep\xf3j\xe1t b\xf6ng\xe9szi, hogy mindenk\xe9ppen van legal\xe1bb egy benchmark \xe1bra arr\xf3l, hogy gyorsabb, mint a t\xf6bbi. Alapvet\u0151en a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/microsoft/mimalloc"},"mi_malloc")," Microsoft \xe1ltal k\xe9sz\xedtett implement\xe1ci\xf3t teszteltem, de sz\xe1mos m\xe1s el\xe9rhet\u0151 megold\xe1s van. Teljess\xe9g ig\xe9nye n\xe9lk\xfcl: tcmalloc, rpmalloc, jemalloc stb... Val\xf3ban gyorsabb az allok\xe1l\xe1si id\u0151, de m\xe9g mindig nem annyira effekt\xedv megold\xe1s, mint egy pool allok\xe1tor."),(0,r.kt)("h3",{id:"pool-allok\xe1torok"},"Pool allok\xe1torok"),(0,r.kt)("p",null,'A pool allok\xe1torok seg\xedts\xe9g\xe9vel a dinamikus mem\xf3riafoglal\xe1ssal j\xe1r\xf3 k\xf6lts\xe9gen tudunk sp\xf3rolni az\xe1ltal, hogy a program kezdetekor lefoglalunk egy meghat\xe1rozott, jellemz\u0151en nagyobb mem\xf3riablokkot, \xe9s a k\xe9s\u0151bbi "mem\xf3riafoglal\xe1sainkat" ebb\u0151l a m\xe1r lefoglalt blokkb\xf3l vonjuk el. C\xe9lszer\u0171 minden egyes ind\xedtott sz\xe1lra sz\xe1lspecifikusan inicializ\xe1lni egy allok\xe1tor objektumot. A megold\xe1s h\xe1tr\xe1nya, hogy \xedgy a programunk fut\xe1sid\u0151ben v\xe9lhet\u0151en t\xf6bb mem\xf3ri\xe1t fog haszn\xe1lni. Ett\u0151l eltekintve \xe9n alapvet\u0151en ezt az ir\xe1nyt prefer\xe1lom.'),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Allocations example",src:a(5620).Z})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"(A stack alap\xfa allok\xe1torok stackoverflow hib\xe1val elsz\xe1lltak...)")),(0,r.kt)("p",null,"Megl\xe9v\u0151 pool allok\xe1torral pedig semmi ideig nem tart lecser\xe9lni (az am\xfagy sem k\xf6zkedvelt) alap\xe9rtelmezett ",(0,r.kt)("inlineCode",{parentName:"p"},"std::allocator"),"-t."),(0,r.kt)("h2",{id:"gpu-offloading"},"GPU offloading"),(0,r.kt)("p",null,"A heterog\xe9n processzorokkal v\xe9gzett egyidej\u0171 munkav\xe9gz\xe9s egy mostan\xe1ban vir\xe1gkor\xe1t \xe9l\u0151 t\xe9mak\xf6r, legf\u0151k\xe9pp a kutat\xe1si c\xe9l\xfa, sz\xe1m\xedt\xe1sig\xe9nyes felhaszn\xe1l\xe1s ter\xe9n. A r\xe9gi id\u0151kben egy-egy processzor gener\xe1ci\xf3 v\xe1lt\xe1sn\xe1l sokkal szembet\u0171n\u0151bb teljes\xedtm\xe9nyn\xf6veked\xe9s volt tapasztalhat\xf3, azonban ez a n\xf6veked\xe9s id\u0151r\u0151l id\u0151re egyre csak cs\xf6kken. Ennek kiegyens\xfalyoz\xe1s\xe1ra tal\xe1lt\xe1k ki, hogy az elv\xe9gzend\u0151 alsz\xe1m\xedt\xe1sokat (melyek legink\xe1bb lebeg\u0151pontos \xe9s t\xf6mb\xf6kkel kapcsolatos m\u0171veletekre vonatkoznak) legyen lehet\u0151s\xe9g sz\xe9tosztani a CPU-t\xf3l elt\xe9r\u0151 eszk\xf6z\xf6k\xf6n is. Legjellemz\u0151bb ilyen eszk\xf6z\xf6k a vide\xf3k\xe1rty\xe1k \xe9s az FPGA-k. Mivel a vide\xf3k\xe1rty\xe1s felhaszn\xe1l\xe1snak van \xe1ltal\xe1nosan \xe9rtelme, ez\xe9rt ink\xe1bb ezzel foglalkoztam.",(0,r.kt)("br",null),(0,r.kt)("br",null),"\nA k\xe9t legnevezetesebb platform a vide\xf3k\xe1rty\xe1k programoz\xe1s\xe1ra a Cuda \xe9s az OpenCL.\nMindkett\u0151 tulajdons\xe1ga, hogy a vide\xf3k\xe1rty\xe1ra specializ\xe1lt met\xf3dusokat (kernelk\xf3dot) k\xfcl\xf6n f\xe1jlban vagy string liter\xe1lk\xe9nt kell t\xe1rolni.\nHa nem szeretn\xe9k alacsony szinten kezelni ezeket a technol\xf3gi\xe1kat, aj\xe1nlott a Khronos Group \xe1ltal el\u0151terjesztett specifik\xe1ci\xf3, a SYCL, \xe9s ennek valamely implement\xe1ci\xf3j\xe1nak haszn\xe1lata, att\xf3l f\xfcgg\u0151en, hogy milyen eszk\xf6zt\xe1mogat\xe1sra van sz\xfcks\xe9g\xfcnk.",(0,r.kt)("br",null),(0,r.kt)("br",null),"\n",(0,r.kt)("img",{alt:"SYCL implementations",src:a(6375).Z}),"\nT\xf6bb implement\xe1ci\xf3 sajnos nem multiplatform \xe9s kifejezetten ford\xedt\xf3specifikusak.",(0,r.kt)("br",null),"\nFontos megjegyezni, hogy a legt\xf6bb C++ nyelvi elem nem haszn\xe1lhat\xf3 kernelk\xf3d k\xf6rnyezetben.\nA projekt szempontj\xe1b\xf3l b\u0151s\xe9gesen elegend\u0151 az OpenCL \xe1ltal ny\xfajtott interf\xe9sz, de mivel a ComputeCpp projekt integr\xe1l\xe1sa megoldhat\xf3nak t\u0171nik multiplatform felt\xe9telekkel, \xedgy nem kiz\xe1rt, hogy k\xe9s\u0151bbiekben ez ker\xfcl haszn\xe1latba.",(0,r.kt)("br",null),(0,r.kt)("br",null),"\nA munkav\xe9gz\xe9s jellemz\u0151en \xfagy zajlik ezekkel, hogy a hoszt platformon (CPU \xe9s RAM) l\xe9trehozott mem\xf3ri\xe1t \xe1tm\xe1soljuk az eszk\xf6zre, majd a kernelk\xf3dunkat (met\xf3dusunkat) megh\xedvva m\xe1r k\xe9pesek vagyunk a vide\xf3k\xe1rty\xe1n mem\xf3ria manipul\xe1ci\xf3t v\xe9grehajtani.",(0,r.kt)("br",null)," K\xe9t dologra kell csak figyelni."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Sose foglaljunk le t\xfal nagy mem\xf3ri\xe1t a k\xfcls\u0151 eszk\xf6z\xf6n!")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Ne haszn\xe1ljunk olyan logik\xe1t, ami mutex haszn\xe1lat\xe1t ig\xe9nyel, vagy an\xe9lk\xfcl race-condition-t eredm\xe9nyezne!"))),(0,r.kt)("p",null,"Az els\u0151 \xe1ll\xedt\xe1s indokl\xe1sa az, hogy annak ellen\xe9re, hogy nagy mennyis\xe9g\u0171 VRAM \xe1ll rendelkez\xe9s\xfcnkre, annak kezel\xe9se, mivel nem az oper\xe1ci\xf3s rendszert\u0151l f\xfcgg\u0151 hanem az eszk\xf6z drivert\u0151l, sokkal bizonytalanabb \xe9s \xe9rz\xe9kenyebb."),(0,r.kt)("p",null,"A m\xe1sodik \xe1ll\xedt\xe1s oka, hogy mivel egy GPU szerkezeti fel\xe9p\xedt\xe9se teljesen m\xe1s, a jellemz\u0151en sok sz\xe1l egym\xe1ssal t\xf6rt\xe9n\u0151 szinkroniz\xe1l\xe1sa \xe9s v\xe1rakoztat\xe1sa a megszokottn\xe1l is t\xf6bb overheaddel \xe9s ez\xe1ltal teljes\xedtm\xe9nycs\xf6kken\xe9ssel j\xe1r."))}p.isMDXComponent=!0},5620:function(e,t,a){t.Z=a.p+"assets/images/allocations-e3ddb294099e0505fcb0d8660869623f.png"},2133:function(e,t,a){t.Z=a.p+"assets/images/constexpr-418c3c3398ae6e2f81b1b903d74c749f.png"},4151:function(e,t,a){t.Z=a.p+"assets/images/simd-0cbec4a5b69af3699226f756f9bca295.png"},6375:function(e,t,a){t.Z=a.p+"assets/images/sycl-863aed6885fdf0b554111c4915000410.jpg"}}]);